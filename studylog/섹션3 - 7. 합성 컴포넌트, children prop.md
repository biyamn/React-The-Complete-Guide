# 합성 컴포넌트(Component Composition)

### 합성(컴포지션 Compositio) 컴포넌트란?

다른 컴포넌트를 담는 컴포넌트로 사용된다. 종종 컴포넌트에 어떤 자식이 들어올 지 미리 알 수 없는 경우가 있는데, 범용의 “박스” 역할을 하는 `Sidebar` 나 `Dialog` 같은 컴포넌트에서 많이 나타나는 패턴이다.

이러한 경우, `children`이라는 특별한 prop을 통해 자식 요소를 출력에 그대로 전달하는 방법을 사용할 수 있다. 

> 공식 문서: React는 강력한 합성 모델을 가지고 있기 때문에, 컴포넌트 간에 코드를 재사용해야할 때는 상속 대신 합성을 사용하는 것을 권장합니다.
> 

### children이란?

리액트 예약어로 사용되는 특수한 속성 명

# Card 컴포넌트 만들기

**몇 군데에서 공통적으로 갖고 있는 스타일 등을 추출해서 Card 컴포넌트로 만들려고 한다.** 아래 사진을 보면 날짜/제목/가격을 포함하는 ExpenseItem 컴포넌트가 모서리가 둥글고 그림자가 있는 스타일을 가지고 있다. 그리고 이 ExpenseItem들을 감싸는 Expenses 컴포넌트 또한 모서리가 둥글고 그림자가 있는 스타일을 가지고 있다. 이 공통적인 특성을 모아 Card라는 컴포넌트를 만들고, div 대신 쓸 것이다. 

![캡처](https://user-images.githubusercontent.com/101965666/214575866-4ee53654-5694-4cd2-864d-f6f99adbed44.PNG)

> 이러한 `래퍼 컴포넌트`의 장점은?
> 
- 중복 코드를 피하게 해준다.
- 다른 컴포넌트를 깔끔하게 유지할 수 있게 해준다.

공통되는 코드의 자세한 내용은 아래와 같다. 

```jsx
border-radius: 12px;
box-shadow: 0 1px 8px rgba(0, 0, 0, 0.25);
```

Card 컴포넌트를 만들어줬다.

```jsx
import './Card.css';

function Card(props) {

  return (
    <div>
      
    </div>)
}

export default Card;
```

그리고 Card.css에 공통된 스타일을 넣어줬다.

```jsx
.card {
  border-radius: 12px;
  box-shadow: 0 1px 8px rgba(0, 0, 0, 0.25);
}
```

그리고 ExpenseItem(날짜/제목/가격을 포함하는 컴포넌트)에서 가장 바깥쪽의 div를 Card로 바꿔줬다. 

```jsx
// ExpenseItem.js

import "./ExpenseItem.css";
import ExpenseDate from "./ExpenseDate";
import Card from "./Card";

function ExpenseItem(props) {
  return (
    <Card className="expense-item">
      <ExpenseDate date={props.date} />
      <div className="expense-item__description">
        <h2>{props.title}</h2>
        <div className="expense-item__price">
          ₩{props.amount.toLocaleString()}
        </div>
      </div>
    </Card>
  );
}

export default ExpenseItem;
```

그리고 ExpenseItem.js에서 div 대신 Card를 사용했으므로 css 파일에서 `.expense-item`에서 border-radius와 box-shadow에 해당하는 부분을 삭제했다.

```jsx
<Card className="expense-item">
```

하지만 이렇게 하면 화면이 오류도 없는 빈 화면이 뜬다. 무엇이 문제일까?

강의에 의하면, 사용자 지정 컴포넌트를 래퍼 컴포넌트로 사용할 수 없기 때문이라고 한다. (내장 html 요소인 `<div>`나 `<h2>`는 동작하는 반면) 

→ 그렇다면 래퍼 컴포넌트를 만들기 위해서는 어떻게 해야 할까?

→ Card.js에서 props를 취하면 ‘사용자가 설정한 적이 없더라도 모든 컴포넌트가 갖는 리액트에 내장된 특별한 props’를 사용할 수 있다. 

`children`을 아래와 같이 써준다.

```jsx
import './Card.css';

function Card(props) {

  return (
    <div>
      {props.children}
    </div>
    )
}

export default Card;
```

그러면 깨지긴 하지만 아래와 같이 요소가 화면에 뜬다!

![캡처 PNG (2)](https://user-images.githubusercontent.com/101965666/214577344-7976cfa5-2ec0-453e-ab88-55832bd8446e.png)


깨지는 문제는 조금 뒤에 해결해보기로 하고, children을 알아보자. `children`이 뭐길래 이렇게 하면 작동이 되는 걸까?

생각해보면, 이것을 쓰지 않았을 때 빈 화면이 나타났으며 오류도 나오지 않았다. 이를 통해 `children`을 쓰지 않았을 때 Card 컴포넌트 안에 있는 요소들을 읽지 못했다는 것을 알 수 있다. 

리액트에서 단독 컴포넌트가 아닌 다른 컴포넌트를 감싸는 래퍼 컴포넌트로 사용할 때(Card 컴포넌트처럼) 해당 컴포넌트 내에 작성된 요소들이 children이라는 props로 컴포넌트에 전달된다.  래퍼 컴포넌트에서는 반드시 이 `children`을 리턴하는 코드를 포함시켜야 화면에 노출된다!!

+이제는 깨진 화면을 고쳐보자. 단순히 div에 className을 추가해줬는데 복구가 됐다! 이유가 뭘까??

```jsx
import './Card.css';

function Card(props) {
  const classes = 'card ' + props.className;

  return (
    <div className={classes}>
      {props.children}
    </div>
    )
}

export default Card;
```

- 사용자 정의 컴포넌트는 지원하라고 지시한 것만 지원한다.
- 따라서 아래와 같이 Card 컴포넌트에 className이 설정되길 원한다면 Card 컴포넌트를 수정해야 한다.
    
    ```jsx
    <Card className="expense-item">
    ```
    
    - children의 프로퍼티에 className이 있는지, children이라는 props가 어떻게 구성되어 있는 것인지 확인하기 위해 `props`를 console.log로 찍어봤다. props는 children과 className으로 구성되어 있었다!
        
        ![캡처 PNG (3)](https://user-images.githubusercontent.com/101965666/214577710-23c05c93-65d4-4376-bb59-62684734b598.png)
        
    - Card는 className이 ‘expenses’, ‘expense-item’인 곳에서 사용되고 있었다. 그래서 className이  ‘expenses’, ‘expense-item’라고 나온 것이다.
        
        ```jsx
        <Card className='expenses'>
        <Card className="expense-item">
        ```
        
    - 사용자 정의 컴포넌트는 지시한 것만 지원하기 때문에, Card 컴포넌트에서 className를 쓰게 하려면 Card 컴포넌트에 className을 줘야 한다. 그래서 아래와 같이 Card 컴포넌트에서 div에 className을 줘야 한다.
        
        ```jsx
        const classes = 'card ' + props.className;
        console.log('Card props: ', props);
        return (
          <div className={classes}>
            {props.children}
          </div>
          )
        ```
        

# 다른 코드로 children 실습하기

새로운 코드를 짜서 children props를 실습해보기로 했다.

일단 합성 컴포넌트로 만들 Card.js에는 아래와 같은 속성이 있다. 테두리를 둥글게 하는 속성/그림자 속성/마진 속성을 공통으로 갖는 부분에 이 Card 컴포넌트를 쓸 것이다. 

```jsx
// Card.css

.card {
  border-radius: 12px;
  box-shadow: 0 1px 8px rgba(0, 0, 0, 0.25);
  margin: 10px;
}
```

```jsx
// Card.js

import './Card.css';

function Card(props) {
  return (
    <div className=card>
    </div>
  )
}

export default Card;
```

App.js에 이렇게 적어줬다.

```jsx
import './App.css';
import Profile from './components/Profiles';
import Card from './components/Card';

function App() {
  return (
    <Card className='profiles'>
      <Profile />
    </Card>
  );
}

export default App;
```

App.js 안에 있는 Profile 컴포넌트 안에는 다음과 같이 적어줬다.

```jsx
import Card from "./Card";

function Profile({data}) {

  return (
      <Card className='profile'>
        <h2>profile</h2>
        <div>이름: {data.name}</div>
        <div>나이: {data.age}</div>
        <div>mbti: {data.mbti}</div>
      </Card>
  )
}

export default Profile;
```

이렇게만 하면 화면에 아무것도 보이지 않는다. 왜냐하면 Card 컴포넌트는 단독 컴포넌트가 아닌 다른 컴포넌트를 감싸는 래퍼 컴포넌트이기 때문이다.

리액트에서 래퍼 컴포넌트는 안에 작성된 요소들이 children이라는 props로 컴포넌트에 전달되는데, **래퍼 컴포넌트에서는 반드시 이 `children`을 리턴하는 코드를 포함시켜야 화면에 노출된다.**

그래서 `{props.children}`을 써줬다. 하지만 이래도 완벽하지 않다. 왜냐하면, className을 넘겨주지 않았기 때문이다. 

사용자 정의 컴포넌트는 지원하라고 지시한 것만 지원한다. 따라서 Card 컴포넌트에 className이 설정되길 원한다면 코드를 수정해야 한다. 아래에서는 `classes`라는 변수를 만들어서 props.className으로 각 컴포넌트의 이름을 받아 className에 ‘card’와 함께 합쳐줬다. 이렇게 하면 card와 각 className 모두를 className에 포함시켜 이전과 다르게 이에 해당하는 모든 css를 적용시킬 수 있다.

```jsx
import './Card.css';

function Card(props) {
  const classes = 'card ' + props.className;
  return (
    <div className={classes}>
      {props.children}
    </div>
  )
}

export default Card;
```

# 완성!!!!!!

컴포넌트를 나누고, 합성 컴포넌트인 Card를 사용하여 화면에 표시하도록 하는 것에 성공했다. 

![d](https://user-images.githubusercontent.com/101965666/214575286-ea9c55f7-5be8-41a0-a809-142960bdd454.PNG)
