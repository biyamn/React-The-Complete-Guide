# 양식 입력 추가하기

사용자 입력을 받는 ExpenseForm이라는 컴포넌트를 만들어보자. input의 제목으로 label을 사용하고, 입력받는 곳들을 모아 form이라는 태그 안에 담는다. 그리고 form 안에 submit을 타입으로 갖는 버튼을 만든다. 그러면 버튼을 눌렀을 때 입력한 양식이 전송된다.

```jsx
import './ExpenseForm.css';

const ExpenseForm = () => {
  
  return (
    <form>
      <div className='new-expense__controls'>
        <div className='new-expense__control'>
          <label>Title</label>
          <input type='text' />
        </div>
        <div className='new-expense__control'>
          <label>Amount</label>
          <input type='number' min='0.01' step='0.01' />
        </div>
        <div className='new-expense__control'>
          <label>Date</label>
          <input type='date' min='2019-01-01' max='2023-01-31' />
        </div>
      </div>
      <div className='new-expense__actions'>
        <button type='submit'>Add Expense</button>
      </div>
    </form>
  )
}

export default ExpenseForm;
```

# 사용자 입력 리스닝

먼저, onChange를 사용해 입력을 리스닝 해보았다.

onChange는 input 타입에 상관 없이 모두 쓸 수 있다는 장점이 있다. 

titleChangeHandler 함수를 만들어보자. 핸들러는 리스너와 같은 의미이다. 아래와 같이 하면 Title에 한 글자씩 입력될 때마다 콘솔에 “Title change!”가 한번씩 출력된다. 

```python
const ExpenseForm = () => {
  const titleChangeHandler = () => {
    console.log("Title changed!");
  };

  return (
  <form>
    <div className="new-expense__controls">

      <div className="new-expense__control">
        <label>Title</label>
        <input type="text" onChange={titleChangeHandler} />
      </div>
```

💡 그럼 이걸 이용해서 어떻게 사용자 입력을 받는다는 걸까?

💡 자바스크립트 e(event)

- 이벤트 객체(e, event)란, 해당 이벤트의 다양한 정보를 저장한 프로퍼티와 이벤트의 흐름을 제어하는 메서드가 담긴 객체이다.
- handleClick 함수로 어떤 매개변수로 넘겨줄 필요가 없을 때
는 그냥 함수 정의에서 첫 번째 매개변수로 event객체가 자동으로 들어오게 된다. 그래서 정의에서처럼 e로 받아왔으면 그것이 이벤트 객체가 되어 사용할 수 있다.
    
    ```jsx
    //이벤트객체를 제외한 다른 매개변수가 없는 함수의 경우
    handleClick = (e) => {
    	console.log(e);	//이벤트 객체가 브라우저에 출력됨
        }
    <button onClick={handleClick}></button>
    ```
    
- 이벤트 객체 ([https://ko.javascript.info/introduction-browser-events](https://ko.javascript.info/introduction-browser-events))
    1. 이벤트가 발생하면 브라우저는 이벤트 객체라는 것을 만든다. 
    2. 이벤트 객체는 이벤트 핸들러의 첫 번째 인자로 받는다.
    3. 여기에 이벤트에 관한 상세한 정보를 넣는다
    4. 핸들러에 인수 형태로 전달한다
    5. 이벤트가 발생했을 때 이벤트를 발생시킨 요소와 발생한 이벤트에 대한 정보가 담겨있다.
    
    이벤트 객체에서 지원하는 프로퍼티 중 일부는 다음과 같다.
    
    - **event.type:** 브라우저 이벤트 종류. click 등
    - **event.currentTarget:** 이벤트를 처리하는 요소
    - **event.clientX, event.clientY:** 포인터 관련 이벤트에서 커서의 상대 좌표(모니터 기준 좌표가 아닌 브라우저 화면 기준 좌표)
    - **e.currentTarget** - 핸들러를 할당받은 요소 (this와 같음)
    - **e.target** - 실제 이벤트가 발생한 node
    - **e.key** - key값을 문자열로 나타냄
    - **e.keyCode** - key값을 코드로 나타냄 ( *deprecated 라고 하니 이 방법은 지양하도록 하자)
    - **e.defaultPrevented** - preventDefault 호출여부
    - **e.preventDefault()** - 기본으로 실행되는 이벤트를 취소함

다시 강의로 돌아와서,

1. 이벤트가 발생하면(onChange) 브라우저는 이벤트 객체라는 것을 만든다.(event)
2. 여기에 이벤트에 관한 상세한 정보를 넣는다
3. 핸들러에 인수 형태로 전달한다

```jsx
const ExpenseForm = () => {
  const titleChangeHandler = (event) => {
    console.log(event);
  };

  return (
  <form>
    <div className="new-expense__controls">

      <div className="new-expense__control">
        <label>Title</label>
        <input type="text" onChange={titleChangeHandler} />
      </div>
```

위의 코드를 실행한 결과이다. target은 `이벤트가 일어나는 DOM요소`를 가리킨다.

```jsx
SyntheticBaseEvent {_reactName: 'onChange', _targetInst: null, type: 'change', nativeEvent: InputEvent, target: input, …}
bubbles: true
cancelable: false
currentTarget: null
defaultPrevented: false
eventPhase: 3
isDefaultPrevented: ƒ functionThatReturnsFalse()
isPropagationStopped: ƒ functionThatReturnsFalse()
isTrusted: true
nativeEvent: InputEvent {isTrusted: true, data: 'ㄴ', isComposing: true, inputType: 'insertCompositionText', dataTransfer: null, …}
**target: input**
timeStamp: 4837.300000011921
type: "change"
_reactName: "onChange"
_targetInst: null
[[Prototype]]: Object
```

이러한 input에는 긴 프로퍼티 목록이 있다. 여기서 가장 중요한 것은 속성으로 `value`를 갖는다는 건데, `**이벤트가 벌어졌을 시점의 현재 입력값**`을 갖는다. 

따라서 아래와 같이 치면 키보드를 누를 때마다 그 시점의 현재 값이 출력된다.

```jsx
const ExpenseForm = () => {
  const titleChangeHandler = (event) => {
    console.log(event.target.value);
  };
```

# 사용자 입력값 저장하기

이제 어딘가에 값을 저장해서 나중에 폼이 넘겨졌을 때 그 값을 사용할 수 있도록 해야 한다.

이를 가능하게 하기 위해 `useState`를 사용할 수 있다.

이때 여러개의 State를 사용할 수도, 한 개의 State를 사용할 수도 있으며 개인적인 선호에 따라 선택하면 된다. 

1. **여러개의 State 사용하기**
    
    이렇게 한 컴포넌트에 여러개의 State를 가지고 관리할 수 있다. 
    
    ```jsx
    import { useState } from 'react';
    import './ExpenseForm.css';
    
    const ExpenseForm = () => {
      const [enteredTitle, setEnteredTitle] = useState('');
      const [enteredAmount, setEnteredAmount] = useState('');
      const [enteredDate, setEnteredDate] = useState('');
    
      const titleChangeHandler = (e) => {
        setEnteredTitle(e.target.value);
      }
    
      const amountChangehandler = (e) => {
        setEnteredAmount(e.target.value);
      }
    
      const dateChangehandler = (e) => {
        setEnteredDate(e.target.value);
      }
    
      return (
        <form>
          <div className='new-expense__controls'>
            <div className='new-expense__control'>
              <label>Title</label>
              <input type='text' onChange={titleChangeHandler} />
            </div>
            <div className='new-expense__control'>
              <label>Amount</label>
              <input type='number' min='0.01' step='0.01' onChange={amountChangehandler} />
            </div>
            <div className='new-expense__control'>
              <label>Date</label>
              <input type='date' min='2019-01-01' max='2023-01-31' onChange={dateChangehandler}/>
            </div>
          </div>
          <div className='new-expense__actions'>
            <button type='submit'>Add Expense</button>
          </div>
        </form>
      )
    }
    
    export default ExpenseForm;
    ```
    

1. **한개의 State 사용하기** - *덜 선호됨*
    
    useState를 한 번 호출해서, 값으로 `객체`를 전달하면 된다. 중요한 것은 문자나 숫자가 아니라 **객체**라는 점!
    
    그리고 업데이트될 때 안에 있는 세 값이 모두 업데이트되므로 useState를 사용할 때 스프레드 연산자를 사용하여 사용하지 않는 값들을 복사하고, 그 다음 새로운 값을 업데이트해야 한다.  
    
    ```jsx
    const ExpenseForm = () => {
      // const [enteredTitle, setEnteredTitle] = useState('');
      // const [enteredAmount, setEnteredAmount] = useState('');
      // const [enteredDate, setEnteredDate] = useState('');
    
      const [userInput, setUserInput] = useState({
        enteredTitle: '',
        enteredAmount: '',
        enteredDate: ''
      });
    
      const titleChangeHandler = (event) => {
        // setEnteredTitle(event.target.value);
        setUserInput({
          ...userInput, 
          enteredTitle: event.target.value,
        })
      };
    
      const amountChangeHandler = (event) => {
        // setEnteredAmount(event.target.value);
        setUserInput({
          ...userInput, 
          enteredAmount: event.target.value,
        })
      };
    
      const dateChangeHandler = (event) => {
        // setEnteredDate(event.target.value);
        setUserInput({
          ...userInput, 
          enteredDate: event.target.value,
        })
      };
    ```
    
    → 하지만 위처럼 업데이트하는 것은 특정 상황에서 문제가 될 수 있어 좋은 방법은 아니라고 한다.
    
    동시에 수많은 상태 업데이트를 계획한다면 아래처럼 해야 한다고 한다. 항상 최신 상태를 유지하기 때문이다. ***(강의 58번 - 이전 State에 의존하는 State 업데이트)***
    
    ```jsx
    setUserInput((prevState) => {
          return { ...prevState, enteredTitle: event.target.value};
        });
    ```
    

# 양식 제출 처리

Add Expense라는 버튼을 누르면 ‘submit’되게 되고, 이는 submithandler라는 함수가 실행되게 해보자.

```jsx
<form onSubmit={submithandler}>
```

onSubmit이 되었을 때(submit 버튼을 눌렀을 때) 화면이 새로고침되지 않게 하려면 `preventDefault()`를 사용하자. 

(전송이 되고 바로 페이지가 새로고침되므로, submit을 하면 전송한 데이터가 무조건 갱신된다. 그래서 그러지 않고 페이지에 머무르며 자바스크립트를 사용하기 위해 이 함수를 사용한다.)

```jsx
const submitHandler = (event) => {
  event.preventDefault();
}
```

그리고 submitHandler 함수가 실행되면 이때까지 모은 최신 상태의 enteredTitle, enteredAmout, enteredDate를 각각 title, amount, date라는 프로퍼티에 담았다. 그리고 출력해보면 입력한 세 개의 값들이 모두 잘 입력된 것을 알 수 있다.

```jsx
const submitHandler = (event) => {
  event.preventDefault();

  const expenseData = {
    title: enteredTitle,
    amount: enteredAmount,
    date: new Date(enteredDate),
  }

  console.log(expenseData); 
	// {title: '아무거나', amount: '33', date: Sat Jan 07 2023 09:00:00 GMT+0900 (한국 표준시)}
}
```

# 양방향 바인딩 추가

변경되는 입력값만 수신하는 것이 아니라, 입력에 새로운 값을 다시 전달할 수 있다. 예를 들면 전송한 뒤 입력창을 빈 값으로 초기화하는 것이 있다. 이런 것을 양방향 바인딩이라고 한다.

onSubmit 함수가 실행된 후 마지막으로 아래와 같이 빈 문자열로 초기화해주면 입력값 전송 후 입력창에 쓴 값이 없어지는 것을 알 수 있다. 

```jsx
setEnteredTitle('');
setEnteredAmount('');
setEnteredDate('');
```

```jsx
const ExpenseForm = () => {

  const [enteredTitle, setEnteredTitle] = useState('');
  const [enteredAmount, setEnteredAmount] = useState('');
  const [enteredDate, setEnteredDate] = useState('');

  const titleChangeHandler = (e) => {
    setEnteredTitle(e.target.value);
  }

  const amountChangeHandler = (e) => {
    setEnteredAmount(e.target.value);
  }

  const dateChangeHandler = (e) => {
    setEnteredDate(e.target.value);
  }
  const submitHandler = (event) => {
    event.preventDefault();

    const expenseData = {
      title: enteredTitle,
      amount: enteredAmount,
      date: new Date(enteredDate),
    }

    console.log(expenseData);
    
    setEnteredTitle('');
    setEnteredAmount('');
    setEnteredDate('');
  }

  return (
    <form onSubmit={submitHandler}>
      <div className='new-expense__controls'>
        <div className='new-expense__control'>
          <label>Title</label>
          <input type='text' value={enteredTitle || ''} onChange={titleChangeHandler} />
        </div>
        <div className='new-expense__control'>
          <label>Amount</label>
          <input type='number' value={enteredAmount || ''} min='0.01' step='0.01' onChange={amountChangeHandler} />
        </div>
        <div className='new-expense__control'>
          <label>Date</label>
          <input type='date' value={enteredDate || ''} min='2019-01-01' max='2023-01-31' onChange={dateChangeHandler}/>
        </div>
      </div>
      <div className='new-expense__actions'>
        <button type='submit'>Add Expense</button>
      </div>
    </form>
  )
}

export default ExpenseForm;
```

💥 여기서 궁금한 점이 있다. value가 무엇일까? value를 입력값으로 설정해주지 않으면 전송 버튼을 눌러도 입력창의 문자열이 사라지지 않는 것을 발견했다. 

input 태그의 value 값을 설정해줘야 상태가 바뀌었을 때 input의 내용도 업데이트된다고 한다.(value값을 설정해 주어야 나중에 초기화 버튼을 눌러 input을 비워지게 하는 것이 가능하다.)

전에 input 태그의 value에 대해 언급한 포스팅을 찾았다.

[https://velog.io/@hamham/리액트로-ToDo앱-만들기2-추가편](https://velog.io/@hamham/%EB%A6%AC%EC%95%A1%ED%8A%B8%EB%A1%9C-ToDo%EC%95%B1-%EB%A7%8C%EB%93%A4%EA%B8%B02-%EC%B6%94%EA%B0%80%ED%8E%B8)

즉 정리하면,

1. input 태그 안의 내용을 업데이트하길 원한다면 value를 써줘야 한다.
    - value는 input 창에 입력되는 내용을 가리킨다.
2. input 태그에 value를 쓴다면 onChange를 써야 한다.
    - input 엘리먼트에 value 속성을 지정해 두면 이 엘리먼트는 value 값에 의해서만 변경되기 때문에 사용자가 값을 입력해도 input은 변경되지 않는다.
    - 따라서 이를 해결하려면 `onChange`를 써서 input 값이 변경 가능하도록 만들어야 한다.

# 상향식 컴포넌트 통신(데이터 위로 전달하기)

입력받은 데이터 expenseData를 상위에 있는 App 컴포넌트에 전달하는 방법을 알아보자.  (위로 보내기 위해 중간에 존재하는 컴포넌트들을 모두 거쳐서 보내야 한다.)

1. expenseData(ExpenseForm.js에 위치) → NewExpense.js
    
    ExpenseForm에 onSaveExpenseData라는 props를 넘긴다. 이는 saveExpenseDatahandler를 실행하게 한다. 
    
    ```jsx
    // NewExpense.js
    
    const NewExpense = (props) => {
      const saveExpenseDataHandler = (enteredExpenseData) => {
        const expenseData = {
          ...enteredExpenseData,
          id: Math.random().toString()
        };
        props.onAddExpense(expenseData);
      }
    
      return (
        <div className='new-expense'>
          <ExpenseForm onSaveExpenseData={saveExpenseDataHandler} />
        </div>
      )
    };
    ```
    
    ExpenseForm.js에서는 expenseData가 있는 영역에서 props.onSaveExpenseData에 expenseData를 넘긴다. 그러면 그 함수가 있는 NewExpense.js로 올라간다.
    
    ```jsx
    // ExpenseForm.js
    
    const submitHandler = (event) => {
      event.preventDefault();
    
      const expenseData = {
        title: enteredTitle,
        amount: enteredAmount,
        date: new Date(enteredDate),
      }
    
      props.onSaveExpenseData(expenseData);
    
      setEnteredTitle('');
      setEnteredAmount('');
      setEnteredDate('');
    }
    ```
    

1. expenseData(NewExpense.js에 위치) → App.js
    
    이제 ExpenseForm.js에 있는 expenseData를 App.js까지 올려보자. 컴포넌트를 건너뛸 순 없다. 이렇게 단계를 밟아 올라가야 한다.
    
    NewExpense 컴포넌트에 onAddExpense라는 props를 넘겨준다. onAddExpense는 addExpenseHadler 함수이다. 
    
    ```jsx
    // App.js
    
    const addExpenseHandler = (expense) => {
        console.log(expense);
      }
    
      return (
        <div className="App">
          <NewExpense onAddExpense={addExpenseHandler} />
          <Expenses expenses={expenses}/>
        </div>
      );
    }
    ```
    
    NewExpense 컴포넌트에서는 마찬가지로 expenseData가 있는 곳에서 props.onAddExpense에 expenseData를 넘긴다. 그럼 onAddExpense가 있는 상위 컴포넌트 App으로 expenseData가 넘어가게 된다!
    
    ```jsx
    // NewExpense.js
    
    const NewExpense = (props) => {
      const saveExpenseDataHandler = (enteredExpenseData) => {
        const expenseData = {
          ...enteredExpenseData,
          id: Math.random().toString()
        };
        props.onAddExpense(expenseData);
      }
    ```
    

아래와 같이 한번에 둘 사이에 데이터를 교환할 수는 없다. 데이터를 생성하는 컴포넌트와 데이터가 필요한 컴포넌트가 접근할 수 있어야 한다.(항상 루트 App 컴포넌트까지 상태를 끌어올릴 필요는 없지만, 필요한 만큼은 끌어올려야 한다.)

![캡처](https://user-images.githubusercontent.com/101965666/215535557-fc7f65d7-98c2-492c-a0e1-17b2c03befcd.PNG)
