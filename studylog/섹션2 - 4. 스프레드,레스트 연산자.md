# Spread & Rest Operators(스프레드 & 레스트 연산자)

![캡처 PNG (4)](https://user-images.githubusercontent.com/101965666/213485109-5b448c30-7702-4c56-8b57-164954497378.png)


- ‘…’로 이루어졌다.
- **스프레드 연산자** 예시
    - 배열이나 객체를 펼쳐놓는다.
    - 예시
        
        ```jsx
        const newArray = [...oldArray, 1, 2]
        const newObject = {...oldObject, newProp: 5}
        ```
        
        - …oldArray로 oldArray 배열에 있는 모든 원소들을 새로운 배열에 추가한다.
        - …oldObject로 oldObject의 모든 프로퍼티와 값을 꺼내서 새 객체의 키 값으로 추가한다.

- **레스트 연산자** 예시
    - 레스트 연산자는 객체, 배열, 함수의 파라미터에서 사용 가능하다.
    - 예시
        
        ```jsx
        function sortArgs(...args) {
        	return args.sort() 
        }
        ```
        
    

# Spread Operator 예시

```jsx
const animals = ['개', '고양이', '참새'];
const anotherAnimals = [...animals, '비둘기'];
console.log(animals);
console.log(anotherAnimals);
```

- **기존의 animals 는 건드리지 않으면서,** 새로운 anotherAnimals 배열에 animals 가 가지고 있는 내용을 모두 집어넣고, '비둘기' 라는 항목을 추가적으로 넣었다.

```jsx
const numbers = [1, 2, 3, 4, 5];

const spreadNumbers = [...numbers, 1000, ...numbers];
console.log(spreadNumbers); // [1, 2, 3, 4, 5, 1000, 1, 2, 3, 4, 5]
```

- 배열에서 spread 연산자를 여러번 사용 할 수도 있다.

```jsx
const numbers = [1, 2, 3];
const newNumbers1 = [...numbers, 4];
const newNumbers2 = [numbers, 4];
console.log(newNumbers1); // [1, 2, 3, 4]
console.log(newNumbers2); // [[1, 2, 3], 4]
```

- newNumbers1은 스프레드 연산자를 사용하여 numbers의 원소를 꺼내어 `[1, 2, 3, 4]`와 같은 결과가 나왔지만, newNumbers2는 배열 자체를 배열 안에 추가하여 `[[1, 2, 3], 4]`와 같은 결과가 나왔다.
    
    → 아주 쉽게 배열을 복사하거나, 안전하게 이전 객체를 복사해서 객체에 프로퍼티를 추가할 수 있다!
    
    - 프로퍼티란?
        
        속성이란 뜻으로 자바스크립트에서 객체 내부의 속성을 의미한다. **객체는 프로퍼티로 구성된다. 프로퍼티는 "key(키)" : "value(값)" 의 형식**으로 객체 안의 콤마(쉼표 ,)로 구분되어 할당된다.
        

```jsx
const person = {
  name: 'Max',
}

const newPerson = {
  ...person,
  age: 28,
}

console.log(newPerson) // [object Object] {age: 28, name: "Max"}
```

### Spread Operator를 사용하는 이유

참조가 아니라 그저 값을 복사하기 위해서인 것 같다.

```jsx
let array = [1, 2, 3, 4, 5];
let numbers = [...array];
console.log(numbers); // [1, 2, 3, 4, 5]
array[5] = 6;
console.log(array); // [1, 2, 3, 4, 5, 6]
console.log(numbers); // [1, 2, 3, 4, 5]
```

```jsx
let array = [1, 2, 3, 4, 5];
let numbers = array;
console.log(numbers); // [1, 2, 3, 4, 5]
array[5] = 6;
console.log(array); // [1, 2, 3, 4, 5, 6]
console.log(numbers); // [1, 2, 3, 4, 5, 6]
```

# Rest Operator 예시

> rest는 **객체, 배열, 그리고 함수의 파라미터**에서 사용 가능하다.
> 

### 객체에서 Rest Operator

```jsx
const purpleCuteSlime = {
  name: '슬라임',
  attribute: 'cute',
  color: 'purple'
};

const { color, ...cuteSlime } = purpleCuteSlime;
console.log(color); // "purple"
console.log(cuteSlime); // [object Object] {attribute: "cute", name: "슬라임"}

const { attribute, ...slime } = cuteSlime;
console.log(attribute); // "cute"
console.log(slime); // [object Object] { name: "슬라임"}
```

- rest 는 객체와 배열에서 사용 할 때는 이렇게 비구조화 할당 문법과 함께 사용된다.
- color와 …cuteSlime이 purpleCuteSlime이면 color는 purpleCuteSlime의 color가 되고, …cuteSlime은 purpleCuteSlime에서 color를 뺀 나머지가 된다.
    
    → 객체에서 레스트 연산자는 이런식으로 사용 가능하다.
    

### 배열에서 Rest Operator

```jsx
const numbers = [0, 1, 2, 3, 4, 5, 6];

const [one, ...rest] = numbers;

console.log(one); // 0
console.log(rest); // [1, 2, 3, 4, 5, 6]
```

- 배열 비구조화 할당을 통하여 원하는 값을 밖으로 꺼내고, 나머지 값을 rest 안에 넣었다.

```jsx
const numbers = [0, 1, 2, 3, 4, 5, 6];

const [..rest, last] = numbers;
```

- 반면 이렇게 …rest가 앞에 갈 수는 없다

```jsx
const numbers = [0, 1, 2, 3, 4, 5, 6];

const [num1, num2, ...rest] = numbers;
console.log(num1) // 0
console.log(num2); // 1
console.log(rest); // [2, 3, 4, 5, 6]
```

- 이렇게 하면 의도한 대로 나온다.

### 함수에서 Rest Operator

```jsx
function sum(a, b, c, d, e, f, g) {
  let sum = 0;
  if (a) sum += a;
  if (b) sum += b;
  if (c) sum += c;
  if (d) sum += d;
  if (e) sum += e;
  if (f) sum += f;
  if (g) sum += g;
  return sum;
}

const result = sum(1, 2, 3, 4, 5, 6);
console.log(result);
```

```jsx
function sum(...rest) {
  return rest;
}

const result = sum(1, 2, 3, 4, 5, 6);
console.log(result); // [1, 2, 3, 4, 5, 6]
```

```jsx
const filter = (...args) => {
  return args.filter(el => el === 1);
}

console.log(filter(1, 2, 3, 4)); // [1]
```

- 함수의 파라미터가 몇개가 될 지 모르는 상황에서 rest 파라미터를 사용하면 매우 유용하다.
    - 위에서의 sum 함수는 7개의 파라미터를 받아오는데, 아래에서 사용 할때에는 6개만 넣어줬다. 그러면, g 값이 undefined 가 되기 때문에 sum 에 더하는 과정에서 += undefined 를 하게 되면 결과는 NaN 이 되어버린다. 그렇기 때문에 함수에서 하나하나 유효한 값인지 확인해줬었음
- filter함수를 이용해 원소가 1일 때만 반환한다.
- …args라는 레스트 연산자를 통해 몇개의 인자를 받아도 함수가 기능하게 한다.

## Spread 연산자와 Rest 연산자의 차이점

- 잘 모르겠음..